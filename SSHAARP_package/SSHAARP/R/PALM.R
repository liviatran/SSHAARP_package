#'Population Allele Locating Mapmaker
#'
#'Produces a frequency heatmap for a specified amino-acid motif, based on the allele frequency data in the Solberg dataset.
#'
#'@param filename The filename of the local copy of the Solberg dataset - the defaulted filename is the solberg_dataset in the SSHAARP package.
#'@param motif An amino acid motif in the following format: Locus*##$~##$~##$, where ## identifies a peptide position, and $ identifies an amino acid residue. Motifs can include any number of amino acids.
#'@param color A logical parameter that identifies if the heat maps should be made in color (TRUE) or gray scale (FALSE). The default option is TRUE.
#'@param filterMigrant A logical parameter that determines if admixed populations (OTH) and migrant populations (i.e. any complexities with the 'mig') should be excluded from the dataset. The default option is TRUE.
#'
#'@importFrom data.table rbindlist
#'@importFrom gmt gmt.system r2gmt
#'@importFrom DescTools RoundTo
#'
#'@note The produced frequency heatmap is generated by using the Generic Mapping Tools (GMT) R Package, which is an interface between R and the GMT Map-Making software.
#'@note The Solberg dataset is the tab-delimited ‘1-locus-alleles.dat’ text file in the results.zip archive at http://pypop.org/popdata/.
#'@note The Solberg dataset is also prepackaged into SSHAARP as 'solberg_dataset'.
#'@export
#'
#'@return None, but the produced heatmap is written to the user's working directory as a .jpg file, where the filename is "'the input motif'.jpg".
#'
#'@examples
#'#example to produce a color frequency heat map without migrant populations filtered out
#'#PALM("DRB1*26F~28E~30Y", color=TRUE, filterMigrant=FALSE)
#'
#'#example to produce a greyscale heat map with migrant populations filtered out
#'#PALM("DRB1*26F~28E~30Y", color=FALSE, filterMigrant=TRUE)
#'
#'@references Solberg et.al "Balancing selection and heterogeneity across the classical human leukocyte antigen loci: A meta-analytic review of 497 population studies". Human Immunology (2008) 69, 443–464
#'
#'
PALM<-function(motif, filename=SSHAARP::solberg_dataset, color=TRUE, filterMigrant=TRUE){

  #uses dataSubset to read and manipulate the Solberg dataset
  solberg_DS<-dataSubset(motif, filename)

  #if output of solberg_DS after dataSubset is not a dataframe, it is an error
  #return solberg_DS, which contains the error message
  if(is.data.frame(solberg_DS)==FALSE){
    return(solberg_DS)
  }

  #makes an empty list named unique_AWM, where the name of each element is after a unique AWM,
  #which is acquired by using the motif_finder function
  unique_AWM<-sapply(unique(findMotif(motif)$trimmed_allele), function(x) NULL)

  if(length(unique_AWM)==0){
    return(data.frame("Motif"=motif, "Error message"="No alleles possess this motif"))
  }

  #finds unique_AWMs in Solberg dataset and extracts the allele frequency and locus_allele column
  for(y in 1:length(unique_AWM)){
    unique_AWM[[y]]<-solberg_DS[,c(2,3,4,5,6,11,14)][solberg_DS$locus_allele %in% names(unique_AWM[y]),]}

  #subsets out locus_allele pairs with the motif from the alignment but aren't present in the Solberg ds
  unique_AWM<-unique_AWM[sapply(unique_AWM, nrow)>0]

  if(length(unique_AWM)==0){
    return(data.frame("Motif"=motif, "Error message"="No alleles in the Solberg dataset possess this motif"))
  }

  #melts dataframes in list into one big dataframe
  unique_AWM<-rbindlist(unique_AWM)

  #reorders dataframe based on popname alphabetical order
  unique_AWM<-unique_AWM[order(unique_AWM$popname),]

  #makes row names NULL so they are back in sequential enumeration
  row.names(unique_AWM)<-NULL

  #creates a variable named Population Allele Frequencies (PAF), where each element is named after a
  #unique popname for the targeted locus
  #makes each element a list to take in allele frequencies in the next for loop
  PAF<-sapply(unique(solberg_DS$popname), function(x) NULL)

  #for loop for finding allele frequencies for each named element in PAF
  #if multiple entries are present for a given population name, the allele frequencies are added up
  #if the population does not have the motif, the allele frequency is 0, since the entry is not found in unique_AWM
  for(i in 1:length(PAF)){
    PAF[[i]]<-sum(as.numeric(unique_AWM$allele.freq[which((names(PAF[i])==unique_AWM$popname))]))}

  #melts PAF into a two columned df
  PAF<-data.frame(allele_freq = unlist(PAF),
                  popname = rep(names(PAF), sapply(PAF, length)), row.names = NULL, stringsAsFactors = F)

  #merges PAF with solberg_DS data to a new variable, tbm_ds
  #which contains summed up allele frequencies, and relevant contin, complex, locus*allele, and coordinate information
  tbm_ds<-merge(PAF, solberg_DS[!duplicated(solberg_DS$popname),], by="popname")[,c("popname","contin", "complex", "latit", "longit", "allele_freq")]

  #filters out migrant populations if filter_migrant==TRUE
  if(filterMigrant==TRUE){
    #filters out admixed, migrant OTH populations
    motif_map_df<-tbm_ds[tbm_ds$contin!="OTH",]

    #filters out migrant populations in complexity column
    motif_map_df<-motif_map_df[which((grepl("mig", motif_map_df$complex))==FALSE),]}

  if(filterMigrant==FALSE){
    motif_map_df<-tbm_ds}

  #specifies certain rows from motif_map_df to go into a new variable, gmt_converted_data
  gmt_converted_data<-motif_map_df[,c(1,4,5,6)]

  #rerranges format
  gmt_converted_data<-gmt_converted_data[,c("longit", "latit", "allele_freq", "popname")]

  #calls function to convert R object gmt_converted_data to GMT formatted data
  #outputs converted data into local environment
  r2gmt(gmt_converted_data, "motif.xyz")

  #writes motif to working directory so bash script can extract
  #and use it as the title for the map
  write(motif, "motif")


  #checks if user's machine has GMT software installed
  #if not, an error message is returned and the function stops
  gmtOut<-tryCatch({gmt.system("gmt blockmean motif.xyz -R-180/180/-60/80 -I3 > motif.block")}, error=function(cond){gmtOut<<-"Error"})

  if(length(gmtOut)==1){
    return("The GMT software is not installed at the level of your operating system. Please install GMT from http://gmt.soest.hawaii.edu/projects/gmt/wiki/Installing in order to use this function. Refer to the vignette for more information.")
  }

  #finds blockmean of data
  #-60 for lower bound lat
  #+80 for upper bound lat
  #I for every 3x3 mean value, as obtained from gmt.sh file
  gmt.system("gmt blockmean motif.xyz -R-180/180/-60/80 -I3 > motif.block")


  gmt.system("gmt blockmean motif.xyz -R-180/180/-60/80 -I3 > motif.block")

  #grids table using surface
  gmt.system("gmt surface motif.block -R-180/180/-60/80 -Gmotif.grd -I0.5 -T.7 -Ll0")

  #creates basemap with correct motif
  gmt.system("gmt psbasemap -JM6i -R-180/180/-60/80 -B0:.`cat motif`: -K > `cat motif`.ps")

  #uses white background to fill landmasses if color=T
  if(color==TRUE){
    #overlays relevant continents onto basemap
    gmt.system("gmt pscoast -JM6i -R-180/180/-60/80 -A30000 -B0 -G200 -W0.25p -O -K >> `cat motif`.ps")}

  #uses a hashed background to fill landmasses if color=F
  if(color==FALSE){
    gmt.system("gmt pscoast -JM6i -R-180/180/-60/80 -A30000 -B0 -Gp61 -W0.25p -O -K >> `cat motif`.ps")
  }

  #gets upperbound for allele frequencies
  gmt.system("awk '{print $3}' motif.xyz | sort -r | head -1 > upperbound")

  #makes a vector called cpt_interval which contains max allelic information and decile increment needed
  #to form deciles
  #uses readLines to obtain upperbound information from bash, and rounds it to the nearest 0.5
  #uses readLines to obtain decile needed
  cpt_interval<-c(round(as.numeric(readLines("upperbound")), 3), round(as.numeric(readLines("upperbound"))/10,3))

  #creates a vector called decile_interval, which gives decile increments based on cpt_interval information
  decile_interval<-seq(0, cpt_interval[1], cpt_interval[2])

  #writes max allelic frequency (rounded) and increment needed to form deciles
  write(cpt_interval, "max_cpt")

  #writes decile interval without any line breaks
  cat(decile_interval, file="deciles")

  #uses seis color palette if color=T
  if(color==TRUE){
    #makes custom CPT with increments of max_frequency/10 for deciles
    #specifically calls on max_cpt for max frequency and decile increments
    gmt.system("gmt makecpt -Cseis -Iz -T0/`awk '{print $1}' max_cpt`/`awk '{print $2}' max_cpt` > decile.cpt")
  }

  #uses grayscale color palette if color=F
  if(color==FALSE){
    gmt.system("gmt makecpt -Cgray -Iz -T0/`awk '{print $1}' max_cpt`/`awk '{print $2}' max_cpt` > decile.cpt")

  }
  #adds color scale to basemap based on cpt provided -- makes font on legend smaller
  gmt.system("gmt psscale -D0.1i/1.1i/2i/0.3i -Cdecile.cpt --FONT_ANNOT_PRIMARY=10p,Helvetica,black -Np -L -O -K >> `cat motif`.ps")

  #overlays more coastlines with pscoast
  gmt.system("gmt pscoast -JM6i -R-180/180/-60/80 -A30000 -Gc -O -K >> `cat motif`.ps")

  #clips/masks map areas with no data table coverage -- radius of influence increased to 900 km
  gmt.system("gmt psmask motif.xyz -R-180/180/-60/80 -I3 -JM6i -S850k -O -K >> `cat motif`.ps")

  #grids .grd file onto map
  gmt.system("gmt grdimage motif.grd -Cdecile.cpt  -JM6i -R-180/180/-60/80 -O -K >> `cat motif`.ps")

  #makes a contour map using a .grd file
  gmt.system("gmt grdcontour motif.grd -JM6i -Cdecile.cpt -A- -R-180/180/-60/80 -O -K >> `cat motif`.ps")

  #plots longtitude/latitude coordinates onto basemap
  gmt.system("gmt psxy motif.block -R-180/180/-60/80 -JM6i -A -G255 -W0.5p -Sc.05 -O -K >> `cat motif`.ps")

  #calls psmask again to terminate clip path with -C parameter
  gmt.system("gmt psmask motif.xyz -R-180/180/-60/80 -I3 -JM6i -S850k -C -O -K >> `cat motif`.ps")

  #calls pcoast again to re-establish coastlines and -Q parameter to quit clipping
  gmt.system("gmt pscoast -JM6i -R-180/180/-60/80 -A30000 -W0.5 -O -Q  >>  `cat motif`.ps")

  #converts ps map to jpg -- saves into local environment
  #requires Ghostscript in order to execute command
  gmt.system("gmt psconvert `cat motif`.ps -A -Tj -P -Qg4 -E2000")

  #removes gmt.history output file and other irrelevant files
  gmt.system("rm 'gmt.history' 'upperbound' 'decile.cpt' 'deciles' 'motif' 'motif.block' 'motif.grd' 'motif.xyz' `cat motif`.ps 'max_cpt'")

}
